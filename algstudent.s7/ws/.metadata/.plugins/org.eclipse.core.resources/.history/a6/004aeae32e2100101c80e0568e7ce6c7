import java.util.ArrayList;

public class NullPathNode extends Node {
    private int[] visitedNodes; // Guarda los nodos visitados en el camino
    private int currentCost; // Costo acumulado hasta este nodo
    
    // Constructor del nodo, inicializa el estado
    public NullPathNode(int[] visitedNodes, int currentCost, int depth, UUID parentID) {
        this.visitedNodes = visitedNodes;
        this.currentCost = currentCost;
        this.depth = depth;
        this.parentID = parentID;
        this.ID = UUID.randomUUID();
    }
    
    public int getCurrentCost() {
        return currentCost;
    }

    public int[] getVisitedNodes() {
        return visitedNodes;
    }
    
    // Método para calcular el valor heurístico
    @Override
    public void calculateHeuristicValue() {
        // Heurística: costo acumulado + estimación del costo restante (suponiendo que cada nodo se visita lo más barato posible)
        int remainingCost = 0;
        for (int i = 0; i < visitedNodes.length; i++) {
            if (visitedNodes[i] == 0) { // Nodo no visitado
                remainingCost += findCheapestEdge(i); // Estimación del costo mínimo al siguiente nodo
            }
        }
        heuristicValue = currentCost + remainingCost;
    }

    // Estimación del costo más barato para ir al siguiente nodo
    private int findCheapestEdge(int node) {
        int minCost = Integer.MAX_VALUE;
        // Buscar el costo mínimo entre los nodos restantes
        for (int i = 0; i < visitedNodes.length; i++) {
            if (visitedNodes[i] == 0) {
                minCost = Math.min(minCost, weightMatrix[node][i]);
            }
        }
        return minCost;
    }
    
    // Expansión: genera los nodos hijos
    @Override
    public ArrayList<Node> expand() {
        ArrayList<Node> children = new ArrayList<>();
        
        // Crear un nuevo nodo hijo para cada nodo no visitado
        for (int i = 0; i < visitedNodes.length; i++) {
            if (visitedNodes[i] == 0) { // Si el nodo no ha sido visitado
                int[] newVisitedNodes = visitedNodes.clone();
                newVisitedNodes[i] = 1; // Marcar el nodo como visitado
                int newCost = currentCost + weightMatrix[visitedNodes[depth-1]][i]; // Costo acumulado
                NullPathNode child = new NullPathNode(newVisitedNodes, newCost, depth + 1, ID);
                children.add(child);
            }
        }
        return children;
    }

    // Verificar si es la solución: si todos los nodos han sido visitados y el costo está dentro de la tolerancia
    @Override
    public boolean isSolution() {
        for (int node : visitedNodes) {
            if (node == 0) { // Si hay algún nodo sin visitar
                return false;
            }
        }
        return Math.abs(currentCost) <= tolerance; // Verificar si el costo está dentro de la tolerancia
    }
}
