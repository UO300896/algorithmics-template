
import java.util.ArrayList;
import java.util.Arrays;
import java.util.UUID;

import labs.examples.branchandbound.pyramid.utils.Node;

public class NullPathNode extends Node {

    private static final int tolerance = 99;
	private int[] visitedNodes; // 1 para visitado, 0 para no visitado
    private int currentCost; // Costo acumulado hasta el momento
    private int depth; // Número de nodos desarrollados hasta ahora
    private int[][] weightMatrix; // Matriz de pesos del grafo

    public NullPathNode(int[] visitedNodes, int currentCost, int depth, UUID parentID, int[][] weightMatrix, int lastVisitedNode) {
        super();
        this.visitedNodes = visitedNodes;
        this.currentCost = currentCost;
        this.depth = depth;
        this.parentID = parentID;
        this.weightMatrix = weightMatrix;
        this.lastVisitedNode = lastVisitedNode;
        calculateHeuristicValue();
    }

    @Override
    public void calculateHeuristicValue() {
        // Calcular el valor heurístico como el costo acumulado más la estimación del costo restante
        int remainingCost = 0;
        for (int i = 0; i < visitedNodes.length; i++) {
            if (visitedNodes[i] == 0) {  // Nodo no visitado
                remainingCost += findCheapestEdge(i);  // Estimación del costo mínimo
            }
        }
        heuristicValue = currentCost + remainingCost;
    }

    // Estimación del costo más bajo para un nodo no visitado
    private int findCheapestEdge(int node) {
        int minCost = Integer.MAX_VALUE;
        for (int i = 0; i < weightMatrix.length; i++) {
            if (i != node && weightMatrix[node][i] != 0) {
                minCost = Math.min(minCost, Math.abs(weightMatrix[node][i]));
            }
        }
        return minCost;
    }

    @Override
    public ArrayList<Node> expand() {
        ArrayList<Node> children = new ArrayList<>();

        for (int i = 0; i < visitedNodes.length; i++) {
            if (visitedNodes[i] == 0) {
                int[] newVisitedNodes = visitedNodes.clone();
                newVisitedNodes[i] = 1;
                int newCost = currentCost + weightMatrix[lastVisitedNode][i];
                Node child = new NullPathNode(newVisitedNodes, newCost, depth + 1, ID, weightMatrix, i);
                children.add(child);
            }
        }

        return children;
    }


    @Override
    public boolean isSolution() {
        // Verifica si todos los nodos han sido visitados
        for (int node : visitedNodes) {
            if (node == 0) {  // Si algún nodo no ha sido visitado
                return false;
            }
        }
        
        // Verifica si el costo está dentro de la tolerancia
        return Math.abs(currentCost) <= tolerance;
    }

    // Getter para el costo acumulado
    public int getCurrentCost() {
        return currentCost;
    }

    @Override
    public int initialValuePruneLimit() {
        return tolerance;
    }

    @Override
    public String toString() {
        return Arrays.toString(visitedNodes) + " - Cost: " + currentCost;
    }
}

